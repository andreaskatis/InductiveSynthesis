\newcommand{\such}{\,.\,}
\newcommand{\vx}{\vec{x}}
\newcommand{\vy}{\vec{y}}
\newcommand{\Land}{\bigwedge}
\newcommand{\Lor}{\bigvee}
\newcommand{\mbp}{\mathit{MBP}}
\newcommand{\unsat}{\textsc{unsat}}
\newcommand{\sat}{\textsc{sat}}
\newcommand{\valid}{\textsc{valid}\xspace}
\newcommand{\invalid}{\textsc{invalid}\xspace}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}
\newcommand{\tuple}[1]{\langle #1 \rangle}       % tuple (in mathmode)

\newcommand{\aevalalgorithm}{%
\begin{algorithm2e}[tb]
\SetAlgoSkip{}
\SetKwFor{While}{forever}{do}{}
%\SetAlgoNoLine
\SetKw{KwContinue}{continue}
\KwIn{$S(\vx), \exists \vy \such T(\vx,\vy)$.}
\KwOut{Return value $\in \{\valid, \invalid\}$ of ${S(\vx)\!\! \implies\!\! \exists \vy \such T(\vx,\vy)}$.}
\KwData{$\textsc{SmtSolver}$, counter $i$, models $\{m_i\}$, MBPs $\{T_{i}(\vx)\}$, conditions $\{\phi_i({\vx,\vy})\}$.}
\BlankLine
$\textsc{SmtAdd}(S(\vx))$; \\
$i \gets 0$; \\
\While{}{
$i$++; \\
%$res \leftarrow \textsc{SmtSolve}()$\label{alg:check_unsat_s}; \\
\lIf(\label{alg:returnUnsat}){$(\isUnSat(\textsc{SmtSolve}()))$}{\Return \valid }
$\textsc{SmtPush}()$; \\
$\textsc{SmtAdd}(T(\vx,\vy))$; \\
%$res \gets \textsc{SmtSolve}()$\label{alg:find_matching_ass};\\
\lIf(\label{alg:returnSat}){$(\isUnSat(\textsc{SmtSolve}()))$}{\Return \invalid }
$m_i \gets \textsc{SmtGetModel}()$\label{alg:model};\\ 
%$E \leftarrow extrapolate(m)$;\\
$(T_{i},\phi_i({\vx,\vy}))\! \gets\! \textsc{GetMBP}(\vy, m_i, T(\vx,\vy)))$\label{alg:proj};\\
$\textsc{SmtPop}()$;\\
$\textsc{SmtAdd}(\neg {T_{i}})$\label{alg:block}; \\
}
%\Return $res$;
\caption{\aeval \Big($S(\vx), \exists \vy \such T(\vx,\vy)$\Big), cf.~\cite{fedyukovich2015automated} }
\label{alg:ae_val}
\end{algorithm2e}
}

\newcommand{\localfactoralg}{%
\begin{algorithm2e}[t!]
\SetAlgoSkip{}
\SetInd{0.4em}{0.4em}
\SetKwFor{ForAll}{forall}{do}{}
\SetKwFor{For}{for}{do}{}
\KwIn{$y_j \in \vy$, local Skolem relation $\phi(\vx,\vy) = \Land_{y_j \in \vy}(\psi_{y_j}(\vx,y_{j},\ldots, y_{n}))$, Skolem functions $y_{j+1} = f_{j+1}(\vx),\ldots, y_{n} = f_{n}(\vx)$.}
\KwData{Factored formula $\pi_{y_j}(\vx,y_{j}) = L_{y_j} \land U_{y_j} \land M_{y_j} \land V_{y_j} \land E_{y_j} \land N_{y_j}$; assuming (for simplicity of presentation) that $M_{y_j} = \varnothing \land  V_{y_j} = \varnothing$.}
\KwOut{Local Skolem function $y_j = f_j(\vx)$.}
\BlankLine
\For{$(i = n; i > j; i++)$}{
  $\psi_{y_j}(\vx,y_{j},\ldots,y_{n}) \gets \textsc{Substitute}(\psi_{y_j}(\vx,y_{j},\ldots,y_{n}) , y_i, f_i(\vx))$\label{alg:loc_subst};\\
}
\BlankLine

$\pi_{y_j}(\vx,y_{j}) \gets \psi_{y_j}(\vx,y_{j},\ldots,y_{n})$\label{alg:elim_compl};\\
\BlankLine

\lIf(){$(E_{y_j} \neq \varnothing)$}{\Return $E_{y_j}$}

$\pi_{y_j}(\vx,y_{j}) \gets \textsc{Merge}(L_{y_j}, \mathit{MAX}, \pi_{y_j}(\vx,y_{j}))$;\\
$\pi_{y_j}(\vx,y_{j}) \gets \textsc{Merge}(U_{y_j} , \mathit{MIN}, \pi_{y_j}(\vx,y_{j}))$;\\
\BlankLine

\lIf(){$(U_{y_j} = \varnothing \land N_{y_j} = \varnothing)$}{\Return $\textsc{Rewrite}(L_{y_j} , \mathit{GT}, \pi_{y_j}(\vx,y_{j}))$}

\lIf(){$(L_{y_j} = \varnothing  \land N_{y_j} = \varnothing)$}{\Return $\textsc{Rewrite}(U_{y_j} , \mathit{LT}, \pi_{y_j}(\vx,y_{j}))$}
\BlankLine

\lIf(){$(N_{y_j} = \varnothing)$}{\Return $\textsc{Rewrite}(L_{y_j} \land U_{y_j} , \mathit{MID}, \pi_{y_j}(\vx,y_{j}))$}

\Return $\textsc{Rewrite}(L_{y_j} \land U_{y_j} \land N_{y_j}, \mathit{FMID}, \pi_{y_j}(\vx,y_{j}))$\label{alg:loc_inst};\\
\caption{$\textsc{ExtractSkolemFunction}(y_j, \phi(\vx,\vy)$)}
\label{alg:loc}
\end{algorithm2e}
}

\section{Witnessing existential quantifiers with \aeval}
\label{sec:aeval}

Quantifier elimination is a decision procedure that turns a quantified formula into an equivalent quantifier-free formula.
In addition, the quantifier elimination algorithms are often able to discover a Skolem function that represents witnesses for the existentially quantified individual variables (e.g.,~\cite{DBLP:conf/cav/BalabanovJ11,DBLP:journals/sttt/KuncakMPS13,KLXJOIA,Chakraborty15}).
%
Various tasks in verification and synthesis~\cite{DBLP:conf/fmcad/CimattiGMT13,DBLP:conf/popl/BeyeneCPR14,DBLP:conf/nfm/GasconT14} rely on efficient techniques to remove existential quantifiers from formulas in first order logic, thus adjusting the task to be decided by an SMT solver.
In particular, \emph{functional synthesis} aims at computing a function that meets a given input/output relation.
A function with an input $x$ and an output $y$, specified by a relation $f(x,y)$, can be constructed as a by-product of deciding validity of the formula $\forall x \exists y \such f(x,y)$.
Due to a well-known \emph{AE-paradigm} (also referred to as \emph{Skolem paradigm}~\cite{DBLP:conf/popl/PnueliR89}),
the formula $\forall x \exists y \such f(x,y)$ is equivalent to the formula $\exists \mathit{sk} \; \forall x \such f(x, \mathit{sk}(x))$, which means existence of a Skolem function $\mathit{sk}$, such that $f(x,\mathit{sk}(x))$ holds for every $x$.
Thus the key feature in modern quantifier elimination approaches is their ability to produce witnessing Skolem function.

In the rest of the section, we briefly describe the prior work on \aeval to be able (in Sect.~\ref{sec:new}) to present the key contributions on delivering Skolem functions appropriate for the program synthesis from proofs of realizability.

\subsection{Model-Based Projection for Linear Rational Arithmetic}
\label{sec:mbp}

Quantifier elimination of a formula $\exists \vy \such T(\vx,\vy)$ is an expensive procedure that typically proceeds by enumerating all models of an extended formula $T(\vx,\vy)$.
However, in some applications, the quantifier-free formula, fully equivalent to $\exists \vy \such T(\vx,\vy)$, is not even needed.
Instead, it is enough to operate by (possibly incomplete) sets of models.
This idea relies on some notion of projection that under-approximates existential quantification.
In this section, we consider a concept of Model-Based Projections (MBP), recently proposed by~\cite{komuravelli2014smt,Dutertre}.

%In the following, we use vector notation to denote sets of variables (and set-theoretic operators of \emph{subset} $\vu \subseteq \vx$, \emph{complement} $\vx_{\vu} = \vx \setminus \vu$, \emph{union} $\vx = \vu \cup \vx_{\vu}$).
\begin{definition}
\label{def:mbp}
An $\mathit{MBP}_{\vy}$ is a function from models of
$T(\vx,\vy)$ to $\vy$-free formulas
iff:
\begin{gather}
\text{if }m\models T(\vx,\vy) \text{ then } m\models \mathit{MBP}_{\vy}(m,T) \label{mbp.cond1}\\
\mathit{MBP}_{\vy}(m,T) \!\implies\! \exists \vy \such T(\vx,\vy) \label{mbp.cond2}
\end{gather}
\end{definition}

There are finitely many MBPs for fixed  $\vy$ and $T$ and different models $m_1,\ldots,m_n$ (for some $n$):
$T_{1}(\vx),  \ldots, T_{n}(\vx)$, such that
$\exists \vy \such T(\vx,\vy) = \Lor_{i=1}^{n} T_{i}(\vx)$. 

A possible way of implementing an MBP-algorithm was proposed in~\cite{komuravelli2014smt}.
It is based on Loos-Weispfenning (LW)  quantifier-elimination method~\cite{loos1993applying} for Linear Rational Arithmetic (LRA).
Consider formula $\exists \vy \such T(\vx,\vy)$, where $T$ is quantifier-free.
In our simplified presentation,
$\vy$ is singleton, $T$ is in Negation Normal Form (that allows the operator $\neg$ to be applied only to variables), and $y$ appears in the literals only of the form ${y=e}$, ${l<y}$ or ${y<u}$, where $l,u,e$ are $y$-free.
LW states that the equation~\eqref{eq:formula_rewrite} holds:

\begin{equation}
  \exists y \such T (\vx) \equiv \Big( \Lor_{(y = e) \in \mathit{lits}(T)}{T[e]} \lor
  	\Lor_{(l < y) \in \mathit{lits} (T)}{T [l + \epsilon]} \lor
	T[-\infty] \Big)\label{eq:formula_rewrite}
\end{equation} 
\smallskip  

In~\eqref{eq:formula_rewrite}, $\mathit{lits}(T)$ denote the set of literals of $T$, $T[\cdot]$ stands for a \emph{virtual substitution} for the literals containing $y$.
In particular, $T[e]$ substitutes exact values of $y$ ($y=e$), $T[l+\epsilon]$ substitutes the intervals ($l < y$) of possible values of $y$, $T[-\infty]$ substitutes the rest of the literals.
Consequently, a function $\mathit{LRAProj_{T}}$ is an implementation of the $\mathit{MBP}$ function for~\eqref{eq:formula_rewrite}:%
%
\begin{equation}
\begin{aligned}
\label{case:proj_define}
&\mathit{LRAProj}_{T}(m) = \left\{
\begin{array}{ll}
T[e], 			& \mbox{if}\ (y=e) \in \mathit{lits}(T) \land 
			m \models (y = e)\\
T[l+ \epsilon],	& \mbox{else if}\ (l < y) \in \mathit{lits}(T) 
			\land m \models (l < y) \land \\
			& \forall (l'\!<\!y)\!\in\!\mathit{lits}(T) \such \!m\!\models\!\big((l'\!<\!y)\!\!\implies\!\!(l'\! \le\! l)\big)\\
T[-\infty], 		& \mbox{otherwise}	
\end{array}
\right.
\end{aligned}
\end{equation}





\subsection{Validity and Skolem extraction}
\label{sim:check}

\aevalalgorithm  

Skolemization (i.e., introducing Skolem functions) is a well-known
technique for removing existential quantifiers in first order formulas.
%More specifically:
%
%\begin{definition}[cf.~\cite{skolem}]
%\label{def:sk_fun}
Given a formula ${ \exists y \such \psi(\vx, y)}$,
a~\emph{Skolem function} for $y$, $\mathit{sk}_{y}(\vx)$ is a function such that
$\exists y \such \psi(\vx,y)\!\iff\!\psi (\vx, \mathit{sk}_{y} (\vx))$.
%\end{definition}
We generalize the definition of a Skolem function for the case of a
vector of existentially quantified variables $\vy$, by relaxing the
relationships between elements of $\vx$ and $\vy$.
Given a formula ${\exists \vy \such \Psi(\vx, \vy)}$, a~\emph{Skolem relation} for $\vy$ is a relation ${\mathit{Sk}_{\vy} (\vx, \vy)}$ such that 1) $\mathit{Sk}_{\vy} (\vx, \vy) \implies \Psi (\vx, \vy)$ and 2) $\exists \vy \such \Psi(\vx, \vy)\!\iff\!\mathit{Sk}_{\vy} (\vx, \vy)$.
  

The algorithm \aeval for deciding validity and Skolem extraction assumes that a formula $\Psi$ can be transformed
into the form ${\exists \vy \such \Psi(\vx, \vy)} \equiv {S(\vx)
  \!\implies\! \exists \vy \such T(\vx,\vy)}$, where $S(\vx)$ has only
existential quantifiers, and $T(\vx, \vy)$ is quantifier-free.
%
\aeval partitions
the formula, and searches for a witnessing local Skolem relation of
each partition.  \aeval iteratively constructs a set of MBPs $\{T_i(\vx)\}$, each of which 
is connected with a so called local Skolem relation $\phi_i(\vx,\vy)$, such that
$\phi_i(\vx,\vy) \!\implies\! (T_{i}(\vx) \!\iff\!
  T(\vx,\vy))$ (i.e., that make the corresponding projections equisatisfiable with $T$).
While the pseudocode of \aeval is shown in Alg.~\ref{alg:ae_val}, we refer the reader to~\cite{fedyukovich2015automated} for
more detail.

%\aeval is shown in Alg.~\ref{alg:ae_val}.  Given formulas
%$S(\vx)$ and ${\exists \vy \such T(\vx, \vy)}$, it
%decides validity of ${S(\vx)\! \implies\! \exists \vy \!\such\!
%  T(\vx, \vy)}$.  \aeval enumerates the
%models of $S \land T$ and blocks them from $S$.
%In each iteration $i$, it first checks whether
%$S$ is non-empty (line~3) and then looks for a model $m_i$ of $S
%\land T$ (line~\ref{alg:model}).  If $m_i$ is found, \aeval
%gets a projection $T_i$ of $T$ based on $m_i$ (line~\ref{alg:proj})
%and blocks all models contained in $T_i$ from $S$
%(line~\ref{alg:block}).  The algorithm iterates until either it
%finds a model of $S$ that can not be extended to a
%model of $T$ (line~\ref{alg:returnSat}), or all models of $S$
%are blocked (line~\ref{alg:returnUnsat}). In the first case, the input
%formula is invalid. In the second case, every model of $S$ has been extended
%to some model of $T$, and the  formula is valid. 

\newcommand{\skolemcases}{%
\begin{equation}
\label{case:skolem}
\mathit{Sk}_{\vy} (\vx, \vy) \equiv
\begin{cases}
  \phi_{1} (\vx, \vy)  & \text{if } T_1 (\vx) \\
    \phi_{2} (\vx, \vy)  & \text{else if } T_2 (\vx)\\
  \cdots &\text{\qquad else }\cdots \\
  \phi_{n} (\vx, \vy) & \text{\qquad\qquad else } T_n (\vx) \\
\end{cases}
\end{equation}
}

A Skolem relation
${\mathit{Sk}_{\vy} (\vx, \vy)}$ by \aeval maps each
model of $S(\vx)$ to a corresponding model of $T(\vx,\vy)$.
Intuitively, $\phi_i$ maps each model of $S \land T_{i}$ to a model of $T$.
Thus, in order to define the  Skolem relation $\mathit{Sk}_{\vy}(\vx, \vy)$ it is enough to 
match each $\phi_i$ against the corresponding $T_{i}$:

\skolemcases


\subsection{Refining Skolem Relations into Skolem Functions}
\label{sec:new}

\localfactoralg


Since \aeval is an extension of the MBP-algorithm mentioned in Sect.~\ref{sec:mbp},
each $\phi_i$ (in~\eqref{case:skolem}) is constructed from the substitutions made in $T$ to produce $T_{i}$.
Furthermore, 
%(is a condition under which $T$ is equisatisfiable with $T_{i}$).
%We assume that each $\phi_i$ is in the Cartesian form, i.e., a conjunction of
%terms, in which each $y_j \in \vy$ appears at most once:
%\begin{equation}
%\label{eq:phi_conj}
%\phi_i(\vx,\vy) = \Land_{y_j \in \vy}(\psi_{y_j}(\vx,y_{j},\ldots,y_{n}))
%\end{equation}
%
%By construction, each local Skolem relation $\phi(\vx,\vy)$ has a form $\Land_{y_j \in \vy}(\psi_{y_j}(\vx,y_{j},\ldots,y_{n}))$.
%Since
each MBP in \aeval is constructed iteratively for each variable $y_j \in \vy$.
Thus, $y_j$ may depend on the variables of $y_{j+1},\ldots, y_{n}$ that are still not eliminated in the current iteration $j$.
%Each $\psi_{y_j}(\vx,y_{j},\ldots,y_{n})$ is the conjunction $\psi_{y_j}(\vx,y_{j},\ldots,y_{n}) = \Land_{i}(cl_i(\vx,y_{j},\ldots,y_{n}))$, where each $cl_i$ is  an (in)equality.

Inequalities in a Skolem relation are the enemies \arie{enemies?!} of program synthesis.
Indeed, the final implementation should contain assignments to each
existentially quantified variable, which are in general difficult to
get. \arie{What is meant by ``difficult''. Difficult computationally,
  difficult for the current algorithm, etc?}
The Skolem relation provided by \aeval should be post-processed to get rid of inequalities.
We formalize this procedure as finding a Skolem function $f_{y_j}(\vx)$ for each $y_j\in \vy$, such that $(y_j = f_{y_j}(\vx)) \!\implies\! \exists y_{j+1},\ldots,y_{n} \such \psi_{y_j}(\vx,y_{j},\ldots,y_{n}) $.
The key idea is presented in Alg.~\ref{alg:loc}.
The algorithm is applied separately for each $y_j \in \vy$, starting from $y_n$ to $y_1$.
For each $y_j$, assume, we already established Skolem functions $f_{j+1}(\vx),\ldots,f_{n}(\vx)$ for variables $y_{j+1},\ldots,y_n$ in the previous runs of the algorithm. 
%
First, the algorithm substitutes each appearance of variables $y_{j+1},\ldots, y_{n}$ in $\psi_{y_j}$ by $f_{n}(\vx),\ldots,f_{j+1}(\vx)$.
%If for some variable there is no Skolem function to substitute, the algorithm halts with nothing (line~\ref{alg:loc_ret_none}).
Second, %the algorithm uses standard LRA-rules to normalize $\pi_{y_j}(\vx,y_{j})$ into the form $\Land_k \big(y_{j} \sim f_k(\vx)\big)$, i.e., conjunction of
%expressions, left-hand-sides of which are reserved for $y_j$ and ${\sim
%\in \{<, \le, =, \ge, >\}}$.
%For this, it uses the method \textsc{Rewrite} (line~\ref{alg:loc_rewrite}) that rewrites each clause using the following rule (where $g,h$ - are functions over $\vx$, $p,q$ - rational numbers, $\mathit{sgn}$ - a function, returning the sign of the rational number):
%
%\begin{equation}
%{\Big( (g(\vx)+ p\!\times\!y_j}) \sim ( {h(\vx) + q\!\times\!y_j})\Big) \!\implies\! \Big(\big(\mathit{sgn}(p-q)\times y_j \big) \sim \big( -\frac{g(\vx)}{|p-q|} + \frac{h(\vx)}{|p-q|} \big)\Big)  \notag
%\end{equation}
%Finally 
the algorithm gets rid of inequalities by transforming them into
equalities, thus producing a Skolem function. \arie{The first part
  (line~2) is clear, the second part is not. Elaborate more which part
  of the algorithm are responsible for which inequality
  elimination. The sets $L$, $U$, $M$, $V$, $E$, $N$, are not
  defined. It is not clear why $M$ and $V$ are present but assumed to
  be empty.}
In the rest of the section, we show several fundamental rules and properties behind this operation.
For simplicity, we omit some straightforward details on dealing with
non-strict inequalities ($y_j \ge l(\vx)$ and $y_j \le u(\vx)$) since
they are similar strict inequalities ($y_j > l(\vx)$ and $y_j < u(\vx)$).

%If there are exist some, $f(\vx)$ defines some interval for the values for $y_j$.
%Method \textsc{SkolemFunction} obtains equalities 
%rewrites each clause using the following rules:

\grigory{the rest can be compressed if needed}.

\begin{lemma}
After all substitutions at line~\ref{alg:elim_compl} of Alg.~\ref{alg:loc}, each $\psi_{y_j}(\vx,y_{j},\ldots,y_{n})$ is a conjunction of the form
$L_{y_j} \land U_{y_j} \land M_{y_j} \land V_{y_j} \land E_{y_j} \land N_{y_j}$ where
%
$L_{y_j} = \Land_{l}(y_j > l(\vx))$, 
$U_{y_j} = \Land_{u}(y_j < u(\vx))$, 
$M_{y_j} = \Land_{l}(y_j \ge l(\vx))$, 
$V_{y_j} = \Land_{u}(y_j \le u(\vx))$, 
$E_{y_j} = \Land_{e}(y_j = e(\vx))$, 
$N_{y_j} = \Land_{n}(y_j \neq n(\vx))$.
%
\end{lemma}
\begin{proof}
Follows directly from~\eqref{case:proj_define}.
\qed
\end{proof}

The procedure to extract a Skolem function out of a Skolem relation proceeds by analyzing terms in $L_{y_j}$, $U_{y_j}$, $M_{y_j}$, $V_{y_j}$,$E_{y_j}$ and $N_{y_j}$.
If there is at least one conjunct $(y_j = e(\vx)) \in E_{y_j}$ then $(y_j = e(\vx))$ itself is a Skolem function.
Otherwise, the algorithm creates it from the following primitives.

\begin{definition}
Let $l(\vx)$ and $u(\vx)$ be two linear terms,
then operators $\mathit{MAX}$, $\mathit{MIN}$, $\mathit{MID}$, $\mathit{LT}$, $\mathit{GT}$ are defined as follows:
\begin{align*}
\mathit{MAX}(l, u) (\vx) &= ite (l (\vx) < u (\vx), u(\vx), l(\vx)) \notag &
\mathit{MIN}(l, u) (\vx) &= ite (l (\vx) < u (\vx), l(\vx), u(\vx)) \notag \\
\mathit{LT} (u) (\vx) &= u (\vx) -1 \notag &
\mathit{GT} (l) (\vx) &= l (\vx) + 1 \notag \\
\mathit{MID}(l, u) (\vx) &= \frac{l(\vx) + u(\vx)}{ 2} \notag 
\end{align*}
\end{definition}

\begin{lemma}
If $L_{y_j}$ consists of $n>1$ conjuncts then it is equivalent to $y_j > \mathit{MAX} (l_1, \mathit{MAX} (l_2,\ldots \mathit{MAX} (l_{n-1}, l_n) )) (\vx)$.
If $U_{y_j}$ consists of $n>1$ conjuncts then it is equivalent to $y_j < \mathit{MIN} (u_1, \mathit{MIN} (u_2,\ldots \mathit{MIN} (u_{n-1}, u_n) ))(\vx)$.
%If  $M_{y_j}$ consists of $n>1$ conjuncts then it is equivalent to $y_j \ge \mathit{MAX} (l_1, \mathit{MAX} (l_2,\ldots \mathit{MAX} (l_{n-1}$, $ l_n) )) (\vx)$.
%If  $V_{y_j}$ consists of $n>1$ conjuncts then it is equivalent to $y_j \le \mathit{MIN} (u_1$, $\mathit{MIN} (u_2,\ldots \mathit{MIN} (u_{n-1}, u_n) )) (\vx)$.
\end{lemma}
Similar for $M_{y_j}$ and for $V_{y_j}$. From this point on, with out
loss of generality, we assume that each $L_{y_j}$, $U_{y_j}$,
$M_{y_j}$, $V_{y_j}$ have at most one conjunct.\arie{Check}

\begin{lemma}
If $L_{y_j}$ consists of 1 conjunct and the rest of $U_{y_j}$, $M_{y_j} $,$V_{y_j}$,$E_{y_j}$ and $N_{y_j}$ are empty then the Skolem can be rewritten into $y_j = \mathit{GT} (l)(\vx)$.
\end{lemma}
Similar for $U_{y_j}$ (Skolem  rewritten into $y_j = \mathit{MID} (u)(\vx)$).

\begin{lemma}
If $L_{y_j}$, $U_{y_j}$  consist of 1 conjunct each, and the rest of $M_{y_j} $,$V_{y_j}$, $E_{y_j}$ and $N_{y_j}$ are empty then the Skolem can be rewritten into $y_j = \mathit{MID} (l, u)(\vx)$. 
\end{lemma}
Similar for $M_{y_j}$ and $V_{y_j}$, and for combinations with $L_{y_j}$ and $U_{y_j}$.


\begin{lemma}
  \arie{It is not clear where $h$ comes from}
If $L_{y_j}$, $U_{y_j}$ and $N_{y_j}$ consist of 1 conjunct each and the rest of $M_{y_j} $,$V_{y_j}$,$E_{y_j}$ and $N_{y_j}$ are empty then the Skolem can be rewritten into $y_j = \mathit{FMID} (l, u, h)(\vx)$, where%
\begin{align}
\mathit{FMID}(l, u, h) (\vx) = ite (&\mathit{MID}(l, u) (\vx) = h(\vx),  \notag \\
                          &\mathit{MID}(l, \mathit{MID}(l, u)) (\vx), \notag \\
                          &\mathit{MID}(l, u) (\vx)) \notag 
\end{align}
\end{lemma}
Similar for $M_{y_j}$ and $V_{y_j}$. 
For bigger number of conjuncts of $N_{y_j}$, the Skolem gets rewritten
in a similar way cascadically\arie{Not a word}.


\begin{lemma}
If $L_{y_j}$, $N_{y_j}$  consist of 1 conjunct each, and the rest of $M_{y_j} $,$V_{y_j}$, $E_{y_j}$ and $U_{y_j}$ are empty then the Skolem can be rewritten into $y_j = \mathit{FMID} (l, GT(l))(\vx)$. 
\end{lemma}
Similar for $M_{y_j}$.


\begin{lemma}
If $U_{y_j}$, $N_{y_j}$  consist of 1 conjunct each, and the rest of $M_{y_j} $,$V_{y_j}$, $E_{y_j}$ and $L_{y_j}$ are empty then the Skolem can be rewritten into $y_j = \mathit{FMID} (LT(u), u)(\vx)$. 
\end{lemma}
Similar for $V_{y_j}$.


\begin{theorem}[Soundness]
Iterative application of Alg.~\ref{alg:loc} to all variables $y_n,\ldots,y_1$ returns a local Skolem function to be used in~\eqref{case:skolem}.
\end{theorem}
\begin{proof}
Follows from the case analysis that applies the lemmas above.
\qed
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "document"
%%% End:
